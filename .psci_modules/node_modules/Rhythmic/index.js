"use strict";
var Control_Alt = require("../Control.Alt/index.js");
var Control_Applicative = require("../Control.Applicative/index.js");
var Control_Apply = require("../Control.Apply/index.js");
var Control_Bind = require("../Control.Bind/index.js");
var Data_Foldable = require("../Data.Foldable/index.js");
var Data_Functor = require("../Data.Functor/index.js");
var Data_Identity = require("../Data.Identity/index.js");
var Data_List = require("../Data.List/index.js");
var Data_List_Types = require("../Data.List.Types/index.js");
var Data_Maybe = require("../Data.Maybe/index.js");
var Data_Show = require("../Data.Show/index.js");
var Text_Parsing_Parser = require("../Text.Parsing.Parser/index.js");
var Text_Parsing_Parser_Combinators = require("../Text.Parsing.Parser.Combinators/index.js");
var Text_Parsing_Parser_Language = require("../Text.Parsing.Parser.Language/index.js");
var Text_Parsing_Parser_String = require("../Text.Parsing.Parser.String/index.js");
var Text_Parsing_Parser_Token = require("../Text.Parsing.Parser.Token/index.js");
var Full = (function () {
    function Full(value0, value1) {
        this.value0 = value0;
        this.value1 = value1;
    };
    Full.create = function (value0) {
        return function (value1) {
            return new Full(value0, value1);
        };
    };
    return Full;
})();
var K = (function () {
    function K(value0) {
        this.value0 = value0;
    };
    K.create = function (value0) {
        return new K(value0);
    };
    return K;
})();
var InverseK = (function () {
    function InverseK(value0) {
        this.value0 = value0;
    };
    InverseK.create = function (value0) {
        return new InverseK(value0);
    };
    return InverseK;
})();

// relevant structures above this one:
// Program = [Expression]
// Expression = Expression Passage Polytemporal
// Passage = Rhythmic Aural
// Polytemporal = Canonic Voicing Nose Encounter
// This file contains the data structures to parse the rhythmic notation that will be the head of the passages. It is based on binary events that are either rests or onsets. The data structure represents all of the possible ways in which these binary options can be invoked by the player. For now, the data structure is called Rhythmic and it should be recursive. It has 5 constructors. 
// 1) Onset: Represents an event that can be a rest or an onset. 
// 2) Subdivision: Represents an event that has nested Rhythmic and which the event's duration is going to be the reciprocal of the length of the list of rhythmics. Example: "xxox" are all onset and all have durations of 1. But "[xxox]" are of type ::Subdivision and all have durations of 1/4. "[x[ox]]" consists of an onset with a duration of 1/2, a rest with dur of 1/4 and an onset with dur of 1/4.
// 3) Repetition: Represnts a Rhythmic that is repeated N times.
// 4) Euclidean: Represents a Rhythmic that has k number of repetitions in a euclidean space of N.
// x) Pattern: represents :: [Rhythmic], a list of Rhythmic structures
// xxox xx[ox]x xx[o[xxx]]x xxox!2 xxox(3,8) [xx](3,8) -- this should be a valid pattern program -- not working
// xxox (just [onset]) should be 1 1 ~1 1 
// xx[ox]x should be 1 1 [~1/2 1/2] 1 -- onsets with one subdivision
// xx[o[xxx]]x should be 1 1 [~1/2[1/6 1/6 1/6]] 1 -- nested subdivisions
// xxox!2 should be 1 1 ~1 1 1 1 ~1 1 -- a repetition
// xxox(3,8) should be 1 1 ~1 1 ~1 ~1 ~1 ~1 ~1 ~1 ~1 ~1 1 1 ~1 1 ~1 ~1 ~1 ~1 ~1 ~1 ~1 ~1 1 1 ~1 1 ~1 ~1 ~1 ~1 -- a euclidean
// [xx(3,8)] should be [1/2 1/2] ~1 ~1 [1/2 1/2] ~1 ~1 [1/2 1/2] ~1 -- euclidean inside a subdivision
// [xox]!2(4,7) 
// [xox(3,5)](3,4,1)
var Onset = (function () {
    function Onset(value0) {
        this.value0 = value0;
    };
    Onset.create = function (value0) {
        return new Onset(value0);
    };
    return Onset;
})();

// relevant structures above this one:
// Program = [Expression]
// Expression = Expression Passage Polytemporal
// Passage = Rhythmic Aural
// Polytemporal = Canonic Voicing Nose Encounter
// This file contains the data structures to parse the rhythmic notation that will be the head of the passages. It is based on binary events that are either rests or onsets. The data structure represents all of the possible ways in which these binary options can be invoked by the player. For now, the data structure is called Rhythmic and it should be recursive. It has 5 constructors. 
// 1) Onset: Represents an event that can be a rest or an onset. 
// 2) Subdivision: Represents an event that has nested Rhythmic and which the event's duration is going to be the reciprocal of the length of the list of rhythmics. Example: "xxox" are all onset and all have durations of 1. But "[xxox]" are of type ::Subdivision and all have durations of 1/4. "[x[ox]]" consists of an onset with a duration of 1/2, a rest with dur of 1/4 and an onset with dur of 1/4.
// 3) Repetition: Represnts a Rhythmic that is repeated N times.
// 4) Euclidean: Represents a Rhythmic that has k number of repetitions in a euclidean space of N.
// x) Pattern: represents :: [Rhythmic], a list of Rhythmic structures
// xxox xx[ox]x xx[o[xxx]]x xxox!2 xxox(3,8) [xx](3,8) -- this should be a valid pattern program -- not working
// xxox (just [onset]) should be 1 1 ~1 1 
// xx[ox]x should be 1 1 [~1/2 1/2] 1 -- onsets with one subdivision
// xx[o[xxx]]x should be 1 1 [~1/2[1/6 1/6 1/6]] 1 -- nested subdivisions
// xxox!2 should be 1 1 ~1 1 1 1 ~1 1 -- a repetition
// xxox(3,8) should be 1 1 ~1 1 ~1 ~1 ~1 ~1 ~1 ~1 ~1 ~1 1 1 ~1 1 ~1 ~1 ~1 ~1 ~1 ~1 ~1 ~1 1 1 ~1 1 ~1 ~1 ~1 ~1 -- a euclidean
// [xx(3,8)] should be [1/2 1/2] ~1 ~1 [1/2 1/2] ~1 ~1 [1/2 1/2] ~1 -- euclidean inside a subdivision
// [xox]!2(4,7) 
// [xox(3,5)](3,4,1)
var Pattern = (function () {
    function Pattern(value0) {
        this.value0 = value0;
    };
    Pattern.create = function (value0) {
        return new Pattern(value0);
    };
    return Pattern;
})();

// relevant structures above this one:
// Program = [Expression]
// Expression = Expression Passage Polytemporal
// Passage = Rhythmic Aural
// Polytemporal = Canonic Voicing Nose Encounter
// This file contains the data structures to parse the rhythmic notation that will be the head of the passages. It is based on binary events that are either rests or onsets. The data structure represents all of the possible ways in which these binary options can be invoked by the player. For now, the data structure is called Rhythmic and it should be recursive. It has 5 constructors. 
// 1) Onset: Represents an event that can be a rest or an onset. 
// 2) Subdivision: Represents an event that has nested Rhythmic and which the event's duration is going to be the reciprocal of the length of the list of rhythmics. Example: "xxox" are all onset and all have durations of 1. But "[xxox]" are of type ::Subdivision and all have durations of 1/4. "[x[ox]]" consists of an onset with a duration of 1/2, a rest with dur of 1/4 and an onset with dur of 1/4.
// 3) Repetition: Represnts a Rhythmic that is repeated N times.
// 4) Euclidean: Represents a Rhythmic that has k number of repetitions in a euclidean space of N.
// x) Pattern: represents :: [Rhythmic], a list of Rhythmic structures
// xxox xx[ox]x xx[o[xxx]]x xxox!2 xxox(3,8) [xx](3,8) -- this should be a valid pattern program -- not working
// xxox (just [onset]) should be 1 1 ~1 1 
// xx[ox]x should be 1 1 [~1/2 1/2] 1 -- onsets with one subdivision
// xx[o[xxx]]x should be 1 1 [~1/2[1/6 1/6 1/6]] 1 -- nested subdivisions
// xxox!2 should be 1 1 ~1 1 1 1 ~1 1 -- a repetition
// xxox(3,8) should be 1 1 ~1 1 ~1 ~1 ~1 ~1 ~1 ~1 ~1 ~1 1 1 ~1 1 ~1 ~1 ~1 ~1 ~1 ~1 ~1 ~1 1 1 ~1 1 ~1 ~1 ~1 ~1 -- a euclidean
// [xx(3,8)] should be [1/2 1/2] ~1 ~1 [1/2 1/2] ~1 ~1 [1/2 1/2] ~1 -- euclidean inside a subdivision
// [xox]!2(4,7) 
// [xox(3,5)](3,4,1)
var Subdivision = (function () {
    function Subdivision(value0, value1) {
        this.value0 = value0;
        this.value1 = value1;
    };
    Subdivision.create = function (value0) {
        return function (value1) {
            return new Subdivision(value0, value1);
        };
    };
    return Subdivision;
})();

// relevant structures above this one:
// Program = [Expression]
// Expression = Expression Passage Polytemporal
// Passage = Rhythmic Aural
// Polytemporal = Canonic Voicing Nose Encounter
// This file contains the data structures to parse the rhythmic notation that will be the head of the passages. It is based on binary events that are either rests or onsets. The data structure represents all of the possible ways in which these binary options can be invoked by the player. For now, the data structure is called Rhythmic and it should be recursive. It has 5 constructors. 
// 1) Onset: Represents an event that can be a rest or an onset. 
// 2) Subdivision: Represents an event that has nested Rhythmic and which the event's duration is going to be the reciprocal of the length of the list of rhythmics. Example: "xxox" are all onset and all have durations of 1. But "[xxox]" are of type ::Subdivision and all have durations of 1/4. "[x[ox]]" consists of an onset with a duration of 1/2, a rest with dur of 1/4 and an onset with dur of 1/4.
// 3) Repetition: Represnts a Rhythmic that is repeated N times.
// 4) Euclidean: Represents a Rhythmic that has k number of repetitions in a euclidean space of N.
// x) Pattern: represents :: [Rhythmic], a list of Rhythmic structures
// xxox xx[ox]x xx[o[xxx]]x xxox!2 xxox(3,8) [xx](3,8) -- this should be a valid pattern program -- not working
// xxox (just [onset]) should be 1 1 ~1 1 
// xx[ox]x should be 1 1 [~1/2 1/2] 1 -- onsets with one subdivision
// xx[o[xxx]]x should be 1 1 [~1/2[1/6 1/6 1/6]] 1 -- nested subdivisions
// xxox!2 should be 1 1 ~1 1 1 1 ~1 1 -- a repetition
// xxox(3,8) should be 1 1 ~1 1 ~1 ~1 ~1 ~1 ~1 ~1 ~1 ~1 1 1 ~1 1 ~1 ~1 ~1 ~1 ~1 ~1 ~1 ~1 1 1 ~1 1 ~1 ~1 ~1 ~1 -- a euclidean
// [xx(3,8)] should be [1/2 1/2] ~1 ~1 [1/2 1/2] ~1 ~1 [1/2 1/2] ~1 -- euclidean inside a subdivision
// [xox]!2(4,7) 
// [xox(3,5)](3,4,1)
var Euclidean = (function () {
    function Euclidean(value0, value1, value2, value3) {
        this.value0 = value0;
        this.value1 = value1;
        this.value2 = value2;
        this.value3 = value3;
    };
    Euclidean.create = function (value0) {
        return function (value1) {
            return function (value2) {
                return function (value3) {
                    return new Euclidean(value0, value1, value2, value3);
                };
            };
        };
    };
    return Euclidean;
})();

// relevant structures above this one:
// Program = [Expression]
// Expression = Expression Passage Polytemporal
// Passage = Rhythmic Aural
// Polytemporal = Canonic Voicing Nose Encounter
// This file contains the data structures to parse the rhythmic notation that will be the head of the passages. It is based on binary events that are either rests or onsets. The data structure represents all of the possible ways in which these binary options can be invoked by the player. For now, the data structure is called Rhythmic and it should be recursive. It has 5 constructors. 
// 1) Onset: Represents an event that can be a rest or an onset. 
// 2) Subdivision: Represents an event that has nested Rhythmic and which the event's duration is going to be the reciprocal of the length of the list of rhythmics. Example: "xxox" are all onset and all have durations of 1. But "[xxox]" are of type ::Subdivision and all have durations of 1/4. "[x[ox]]" consists of an onset with a duration of 1/2, a rest with dur of 1/4 and an onset with dur of 1/4.
// 3) Repetition: Represnts a Rhythmic that is repeated N times.
// 4) Euclidean: Represents a Rhythmic that has k number of repetitions in a euclidean space of N.
// x) Pattern: represents :: [Rhythmic], a list of Rhythmic structures
// xxox xx[ox]x xx[o[xxx]]x xxox!2 xxox(3,8) [xx](3,8) -- this should be a valid pattern program -- not working
// xxox (just [onset]) should be 1 1 ~1 1 
// xx[ox]x should be 1 1 [~1/2 1/2] 1 -- onsets with one subdivision
// xx[o[xxx]]x should be 1 1 [~1/2[1/6 1/6 1/6]] 1 -- nested subdivisions
// xxox!2 should be 1 1 ~1 1 1 1 ~1 1 -- a repetition
// xxox(3,8) should be 1 1 ~1 1 ~1 ~1 ~1 ~1 ~1 ~1 ~1 ~1 1 1 ~1 1 ~1 ~1 ~1 ~1 ~1 ~1 ~1 ~1 1 1 ~1 1 ~1 ~1 ~1 ~1 -- a euclidean
// [xx(3,8)] should be [1/2 1/2] ~1 ~1 [1/2 1/2] ~1 ~1 [1/2 1/2] ~1 -- euclidean inside a subdivision
// [xox]!2(4,7) 
// [xox(3,5)](3,4,1)
var Repetition = (function () {
    function Repetition(value0, value1) {
        this.value0 = value0;
        this.value1 = value1;
    };
    Repetition.create = function (value0) {
        return function (value1) {
            return new Repetition(value0, value1);
        };
    };
    return Repetition;
})();

// Event 
// rhythmicTo
// parseEuclidean:: P Rhythmic
// parseEuclidean = do
//   on <- parseOnset 
//   kno <- parens $ parseKNO
//   pure $ Euclidean on (get1 kno) (get2 kno) (get3 kno)
// parseKNO:: P (Tuple3 Int Int Int)
// parseKNO = do
//   k <- integer
//   _ <- comma
//   n <- integer
//   _ <- optional comma
//   o <- integer <|> pure 0
//   pure $ tuple3 k n o
var tokenParser = Text_Parsing_Parser_Token.makeTokenParser(Data_Identity.monadIdentity)(Text_Parsing_Parser_Language.haskellStyle);
var whitespace = tokenParser.whiteSpace;
var semi = tokenParser.semi;
var reserved = tokenParser.reserved;
var parseOnset = Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser_Combinators.choice(Data_Foldable.foldableArray)(Data_Identity.monadIdentity)([ Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser_String.oneOf(Data_Identity.monadIdentity)([ "x" ]))(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(true)), Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser_String.oneOf(Data_Identity.monadIdentity)([ "o" ]))(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(false)) ]))(function (x) {
    return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(new Onset(x));
});
var parens = tokenParser.parens;
var naturalOrFloat = tokenParser.naturalOrFloat;
var integer = tokenParser.integer;

// parseRepetition should be able to parse any other rhythm parser, in theory on should be: on <- parsePattern but it just does not work...
var parseRepetition = Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(parseOnset)(function (on) {
    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser_String.string(Data_Identity.monadIdentity)("!"))(function () {
        return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(integer)(function (n) {
            return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(new Repetition(on, n));
        });
    });
});
var identifier = tokenParser.identifier;
var fromRhythmicToSubDivisions = function (v) {
    if (v instanceof Onset) {
        return Data_Maybe.Nothing.value;
    };
    if (v instanceof Pattern) {
        return Data_Maybe.Just.create(Data_List.length(v.value0));
    };
    if (v instanceof Euclidean) {
        return new Data_Maybe.Just(v.value2);
    };
    if (v instanceof Repetition) {
        return new Data_Maybe.Just(v.value1);
    };
    if (v instanceof Subdivision) {
        return Data_Maybe.Nothing.value;
    };
    throw new Error("Failed pattern match at Rhythmic (line 98, column 1 - line 98, column 51): " + [ v.constructor.name ]);
};
var $$float = tokenParser["float"];
var rhythmicShowInstance = {
    show: function (v) {
        if (v instanceof Onset) {
            return Data_Show.show(Data_Show.showBoolean)(v.value0);
        };
        if (v instanceof Pattern) {
            return Data_Show.show(Data_List_Types.showList(rhythmicShowInstance))(v.value0);
        };
        if (v instanceof Subdivision) {
            return Data_Show.show(rhythmicShowInstance)(v.value0) + (" subdivided in " + Data_Show.show(Data_List_Types.showList(Data_Maybe.showMaybe(Data_Show.showInt)))(v.value1));
        };
        if (v instanceof Euclidean) {
            return Data_Show.show(euclideanShowInstance)(v.value0) + (" euclidean " + (Data_Show.show(Data_Show.showInt)(v.value1) + ("," + (Data_Show.show(Data_Show.showInt)(v.value2) + ("," + Data_Show.show(Data_Show.showInt)(v.value3))))));
        };
        if (v instanceof Repetition) {
            return Data_Show.show(rhythmicShowInstance)(v.value0) + (" times " + Data_Show.show(Data_Show.showInt)(v.value1));
        };
        throw new Error("Failed pattern match at Rhythmic (line 76, column 1 - line 81, column 60): " + [ v.constructor.name ]);
    }
};
var euclideanShowInstance = {
    show: function (v) {
        if (v instanceof Full) {
            return Data_Show.show(rhythmicShowInstance)(v.value0) + ("on ks and not on ks " + Data_Show.show(rhythmicShowInstance)(v.value1));
        };
        if (v instanceof K) {
            return Data_Show.show(rhythmicShowInstance)(v.value0);
        };
        if (v instanceof InverseK) {
            return Data_Show.show(rhythmicShowInstance)(v.value0);
        };
        throw new Error("Failed pattern match at Rhythmic (line 71, column 1 - line 74, column 29): " + [ v.constructor.name ]);
    }
};
var comma = tokenParser.comma;
var parseFull = Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(parseOnset)(function (kPatt) {
    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(comma)(function () {
        return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(parseOnset)(function (invPatt) {
            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(comma)(function () {
                return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(integer)(function (k) {
                    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(comma)(function () {
                        return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(integer)(function (n) {
                            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser_Combinators.optional(Data_Identity.monadIdentity)(comma))(function () {
                                return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(integer)(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(0)))(function (o) {
                                    return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(new Euclidean(new Full(kPatt, invPatt), k, n, o));
                                });
                            });
                        });
                    });
                });
            });
        });
    });
});
var parseInv = Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser_String.string(Data_Identity.monadIdentity)("inv"))(function () {
    return Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(whitespace)(function () {
        return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(parseOnset)(function (invPatt) {
            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(comma)(function () {
                return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(integer)(function (k) {
                    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(comma)(function () {
                        return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(integer)(function (n) {
                            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser_Combinators.optional(Data_Identity.monadIdentity)(comma))(function () {
                                return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(integer)(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(0)))(function (o) {
                                    return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(new Euclidean(new InverseK(invPatt), k, n, o));
                                });
                            });
                        });
                    });
                });
            });
        });
    });
});
var parseK = Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(parseOnset)(function (kPatt) {
    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(comma)(function () {
        return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(integer)(function (k) {
            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(comma)(function () {
                return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(integer)(function (n) {
                    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser_Combinators.optional(Data_Identity.monadIdentity)(comma))(function () {
                        return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(integer)(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(0)))(function (o) {
                            return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(new Euclidean(new K(kPatt), k, n, o));
                        });
                    });
                });
            });
        });
    });
});

// data Euclidean = Full Rhythmic Rhythmic | K Rhythmic | InverseK Rhythmic
// same here
var parseEuclidean = Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser_Combinators.choice(Data_Foldable.foldableArray)(Data_Identity.monadIdentity)([ Text_Parsing_Parser_Combinators["try"](Data_Identity.monadIdentity)(parens(parseFull)), Text_Parsing_Parser_Combinators["try"](Data_Identity.monadIdentity)(parens(parseK)), Text_Parsing_Parser_Combinators["try"](Data_Identity.monadIdentity)(parens(parseInv)) ]))(function (x) {
    return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(x);
});

//-- parseSubDivision should be able to parse patterns
var parseSubDivision = Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser_String.string(Data_Identity.monadIdentity)("["))(function () {
    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser_Combinators.sepBy(Data_Identity.monadIdentity)(Text_Parsing_Parser_Combinators.choice(Data_Foldable.foldableArray)(Data_Identity.monadIdentity)([ Text_Parsing_Parser_Combinators["try"](Data_Identity.monadIdentity)(parseEuclidean), Text_Parsing_Parser_Combinators["try"](Data_Identity.monadIdentity)(parseRepetition), Text_Parsing_Parser_Combinators["try"](Data_Identity.monadIdentity)(parseOnset) ]))(whitespace))(function (x) {
        return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser_String.string(Data_Identity.monadIdentity)("]"))(function () {
            return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(Subdivision.create(Pattern.create(Data_List.fromFoldable(Data_List_Types.foldableList)(x)))(Data_List.fromFoldable(Data_List_Types.foldableList)(Data_Functor.map(Data_List_Types.functorList)(fromRhythmicToSubDivisions)(x))));
        });
    });
});
var parsePattern = Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser_Combinators.sepBy(Data_Identity.monadIdentity)(Text_Parsing_Parser_Combinators.choice(Data_Foldable.foldableArray)(Data_Identity.monadIdentity)([ Text_Parsing_Parser_Combinators["try"](Data_Identity.monadIdentity)(parseSubDivision), Text_Parsing_Parser_Combinators["try"](Data_Identity.monadIdentity)(parseEuclidean), Text_Parsing_Parser_Combinators["try"](Data_Identity.monadIdentity)(parseRepetition), Text_Parsing_Parser_Combinators["try"](Data_Identity.monadIdentity)(parseOnset) ]))(whitespace))(function (x) {
    return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(Pattern.create(Data_List.fromFoldable(Data_List_Types.foldableList)(x)));
});
var colon = tokenParser.colon;
var brackets = tokenParser.brackets;
var braces = tokenParser.braces;
module.exports = {
    Onset: Onset,
    Pattern: Pattern,
    Subdivision: Subdivision,
    Euclidean: Euclidean,
    Repetition: Repetition,
    Full: Full,
    K: K,
    InverseK: InverseK,
    parsePattern: parsePattern,
    parseSubDivision: parseSubDivision,
    fromRhythmicToSubDivisions: fromRhythmicToSubDivisions,
    parseOnset: parseOnset,
    parseRepetition: parseRepetition,
    parseEuclidean: parseEuclidean,
    parseFull: parseFull,
    parseK: parseK,
    parseInv: parseInv,
    tokenParser: tokenParser,
    parens: parens,
    braces: braces,
    identifier: identifier,
    reserved: reserved,
    naturalOrFloat: naturalOrFloat,
    "float": $$float,
    whitespace: whitespace,
    colon: colon,
    brackets: brackets,
    comma: comma,
    semi: semi,
    integer: integer,
    euclideanShowInstance: euclideanShowInstance,
    rhythmicShowInstance: rhythmicShowInstance
};
