// Generated by purs version 0.15.4
import * as AST from "../AST/index.js";
import * as Data_Bifunctor from "../Data.Bifunctor/index.js";
import * as Data_Boolean from "../Data.Boolean/index.js";
import * as Data_DateTime_Instant from "../Data.DateTime.Instant/index.js";
import * as Data_Eq from "../Data.Eq/index.js";
import * as Data_EuclideanRing from "../Data.EuclideanRing/index.js";
import * as Data_Foldable from "../Data.Foldable/index.js";
import * as Data_Functor from "../Data.Functor/index.js";
import * as Data_Int from "../Data.Int/index.js";
import * as Data_List from "../Data.List/index.js";
import * as Data_List_Lazy from "../Data.List.Lazy/index.js";
import * as Data_List_Lazy_Types from "../Data.List.Lazy.Types/index.js";
import * as Data_List_NonEmpty from "../Data.List.NonEmpty/index.js";
import * as Data_List_Types from "../Data.List.Types/index.js";
import * as Data_Maybe from "../Data.Maybe/index.js";
import * as Data_Newtype from "../Data.Newtype/index.js";
import * as Data_Ord from "../Data.Ord/index.js";
import * as Data_Semiring from "../Data.Semiring/index.js";
import * as Data_Show from "../Data.Show/index.js";
import * as Data_Tempo from "../Data.Tempo/index.js";
import * as Data_Traversable from "../Data.Traversable/index.js";
import * as Data_Tuple from "../Data.Tuple/index.js";
import * as Debug from "../Debug/index.js";
import * as Helpers from "../Helpers/index.js";
var add = /* #__PURE__ */ Data_Semiring.add(Data_Semiring.semiringNumber);
var foldl = /* #__PURE__ */ Data_Foldable.foldl(Data_List_Lazy_Types.foldableList);
var map = /* #__PURE__ */ Data_Functor.map(Data_List_Types.functorList);
var foldl1 = /* #__PURE__ */ Data_Foldable.foldl(Data_List_Types.foldableList);
var scanl = /* #__PURE__ */ Data_Traversable.scanl(Data_List_Types.traversableList);
var fromFoldable = /* #__PURE__ */ Data_List.fromFoldable(Data_List_Lazy_Types.foldableList);
var unwrap = /* #__PURE__ */ Data_Newtype.unwrap();
var fromFoldable1 = /* #__PURE__ */ Data_List.fromFoldable(Data_Foldable.foldableArray);
var sort = /* #__PURE__ */ Data_List.sort(/* #__PURE__ */ Data_Tuple.ordTuple(AST.ordOnset)(Data_Ord.ordNumber));
var eq1 = /* #__PURE__ */ Data_Eq.eq(AST.eqSeqType);
var mod = /* #__PURE__ */ Data_EuclideanRing.mod(Data_EuclideanRing.euclideanRingInt);
var add1 = /* #__PURE__ */ Data_Semiring.add(Data_Semiring.semiringInt);
var lmap = /* #__PURE__ */ Data_Bifunctor.lmap(Data_Bifunctor.bifunctorTuple);
var trace = /* #__PURE__ */ Debug.trace();
var show = /* #__PURE__ */ Data_Show.show(Data_Show.showInt);
var show1 = /* #__PURE__ */ Data_Show.show(Data_Show.showNumber);
var showTuple = /* #__PURE__ */ Data_Tuple.showTuple(AST.showOnset)(Data_Show.showNumber);
var show2 = /* #__PURE__ */ Data_Show.show(showTuple);
var show3 = /* #__PURE__ */ Data_Show.show(/* #__PURE__ */ Data_List_Types.showList(showTuple));
var sort1 = /* #__PURE__ */ Data_List.sort(Data_Ord.ordNumber);
var groupAll = /* #__PURE__ */ Data_List.groupAll(Data_Ord.ordNumber);
var show4 = /* #__PURE__ */ Data_Show.show(/* #__PURE__ */ Data_List_Types.showList(Data_Show.showNumber));
var wholePart = function (x) {
    return Data_Int.toNumber(Data_Int.floor(x));
};
var toEventIndex = function (refrainindex) {
    return function (intraindex) {
        return refrainindex + intraindex;
    };
};
var rhythmicToRefrainDuration = function (v) {
    if (v instanceof AST.X) {
        return 1.0;
    };
    if (v instanceof AST.O) {
        return 1.0;
    };
    if (v instanceof AST.Sd) {
        return 1.0;
    };
    if (v instanceof AST.Repeat) {
        var x = Data_List_Lazy.replicate(v.value1)(rhythmicToRefrainDuration(v.value0));
        return foldl(add)(0.0)(x);
    };
    if (v instanceof AST.Rhythmics) {
        var x = map(function (x1) {
            return rhythmicToRefrainDuration(x1);
        })(v.value0);
        return foldl1(add)(0.0)(x);
    };
    throw new Error("Failed pattern match at Motor (line 238, column 1 - line 238, column 47): " + [ v.constructor.name ]);
};
var onsetAndIndexEvent = function (x) {
    return function (index) {
        return new Data_Tuple.Tuple(Data_Tuple.fst(x), index);
    };
};
var manyCycles = function (len) {
    return function (grupo) {
        var n = map(function (x) {
            return Data_Maybe.fromMaybe(0.0)(Data_List.head(grupo)) + x;
        })(scanl(add)(0.0)(fromFoldable(Data_List_Lazy.replicate(Data_List.length(grupo))(len))));
        return new Data_List_Types.Cons(Data_Maybe.fromMaybe(0.0)(Data_List.head(grupo)), Data_Maybe.fromMaybe(Data_List_Types.Nil.value)(Data_List.init(n)));
    };
};
var indexedOnsetToEvent = function (v) {
    return function (t) {
        var countInTime = Data_Tempo.countToTime(t)(Helpers.toRat(v.value0.value1));
        var posix = unwrap(Data_DateTime_Instant.unInstant(Data_DateTime_Instant.fromDateTime(countInTime))) / 1000.0;
        return new Data_Tuple.Tuple(posix, new Data_Tuple.Tuple(v.value0.value0, Data_Int.floor(v.value1)));
    };
};
var indexOfRefrain = function (t) {
    return function (wp) {
        return function (rhy) {
            var wpCount = Data_Tempo.timeToCountNumber(t)(wp);
            var refrainDur = rhythmicToRefrainDuration(rhy);
            var indexAsNum = wpCount / refrainDur;
            return new Data_Tuple.Tuple(Data_Int.toNumber(Data_Int.floor(indexAsNum)), Helpers.rightOfpoint(indexAsNum));
        };
    };
};
var getDur = function (v) {
    return v.value1;
};
var getBool = function (v) {
    return v.value0;
};
var eventsDurations$prime = function (dur) {
    return function (v) {
        if (v instanceof AST.X) {
            return fromFoldable1([ new AST.Onset(true, dur) ]);
        };
        if (v instanceof AST.O) {
            return fromFoldable1([ new AST.Onset(false, dur) ]);
        };
        if (v instanceof AST.Sd) {
            return eventsDurations$prime(dur)(v.value0);
        };
        if (v instanceof AST.Repeat) {
            var newDur = dur / Data_Int.toNumber(v.value1);
            return Data_List.concat(map(function (x) {
                return eventsDurations$prime(newDur)(x);
            })(fromFoldable(Data_List_Lazy.replicate(v.value1)(v.value0))));
        };
        if (v instanceof AST.Rhythmics) {
            var newDur = dur / Data_Int.toNumber(Data_List.length(v.value0));
            return Data_List.concat(map(function (x) {
                return eventsDurations$prime(newDur)(x);
            })(v.value0));
        };
        throw new Error("Failed pattern match at Motor (line 278, column 1 - line 278, column 52): " + [ dur.constructor.name, v.constructor.name ]);
    };
};
var eventsDurations = function (dur) {
    return function (v) {
        if (v instanceof AST.X) {
            return fromFoldable1([ new AST.Onset(true, dur) ]);
        };
        if (v instanceof AST.O) {
            return fromFoldable1([ new AST.Onset(false, dur) ]);
        };
        if (v instanceof AST.Sd) {
            return eventsDurations$prime(dur)(v.value0);
        };
        if (v instanceof AST.Repeat) {
            return Data_List.concat(map(function (x) {
                return eventsDurations(dur)(x);
            })(fromFoldable(Data_List_Lazy.replicate(v.value1)(v.value0))));
        };
        if (v instanceof AST.Rhythmics) {
            return Data_List.concat(map(function (x) {
                return eventsDurations(dur)(x);
            })(v.value0));
        };
        throw new Error("Failed pattern match at Motor (line 269, column 1 - line 269, column 51): " + [ dur.constructor.name, v.constructor.name ]);
    };
};
var rhythmicToEventsDuration = function (rhy) {
    var rhythmicSegments = eventsDurations(1.0)(rhy);
    var refrainDur = rhythmicToRefrainDuration(rhy);
    var durInPercentOfEvents = new Data_List_Types.Cons(0.0, Data_Maybe.fromMaybe(new Data_List_Types.Cons(0.0, Data_List_Types.Nil.value))(Data_List.init(scanl(add)(0.0)(map(function (x) {
        return x / refrainDur;
    })(map(getDur)(rhythmicSegments))))));
    return Data_List.zipWith(function (x) {
        return function (y) {
            return new AST.Onset(x, y);
        };
    })(map(getBool)(rhythmicSegments))(durInPercentOfEvents);
};
var durationOfRefrain = function (v) {
    if (v instanceof AST.X) {
        return 1.0;
    };
    if (v instanceof AST.O) {
        return 1.0;
    };
    if (v instanceof AST.Sd) {
        return 1.0;
    };
    if (v instanceof AST.Rhythmics) {
        return Data_Int.toNumber(Data_List.length(v.value0));
    };
    return 2.666;
};
var decimalPart = function (x) {
    return x - wholePart(x);
};
var nextBeat = function (metre) {
    return function (offset) {
        return function (ws) {
            if (metre === 0.0) {
                return 0.0;
            };
            if (Data_Boolean.otherwise) {
                var wsInMetre = ws / metre;
                var offsetInMetre = decimalPart(offset / metre);
                var nextBeatInMetre = (function () {
                    if (offsetInMetre >= decimalPart(wsInMetre)) {
                        return Data_Int.toNumber(Data_Int.floor(wsInMetre)) + offsetInMetre;
                    };
                    if (Data_Boolean.otherwise) {
                        return Data_Int.toNumber(Data_Int.ceil(wsInMetre)) + offsetInMetre;
                    };
                    throw new Error("Failed pattern match at Motor (line 220, column 13 - line 221, column 86): " + [  ]);
                })();
                return nextBeatInMetre * metre;
            };
            throw new Error("Failed pattern match at Motor (line 214, column 1 - line 214, column 48): " + [ metre.constructor.name, offset.constructor.name, ws.constructor.name ]);
        };
    };
};
var findBeats$prime = function (metre) {
    return function (offset) {
        return function (ws) {
            return function (we) {
                if (nextBeat(metre)(offset)(ws) >= we) {
                    return fromFoldable1([  ]);
                };
                if (Data_Boolean.otherwise) {
                    return new Data_List_Types.Cons(nextBeat(metre)(offset)(ws), findBeats$prime(metre)(offset)(ws + metre)(we));
                };
                throw new Error("Failed pattern match at Motor (line 209, column 1 - line 209, column 65): " + [ metre.constructor.name, offset.constructor.name, ws.constructor.name, we.constructor.name ]);
            };
        };
    };
};
var findBeats = function (t) {
    return function (ws$prime) {
        return function (we$prime) {
            return function (metre) {
                return function (offset) {
                    var ws = Data_Tempo.timeToCountNumber(t)(ws$prime);
                    var we = Data_Tempo.timeToCountNumber(t)(we$prime);
                    return findBeats$prime(metre)(offset)(ws)(we);
                };
            };
        };
    };
};
var findBeatsWithOnset = function (t) {
    return function (ws) {
        return function (we) {
            return function (refrainDur) {
                return function (v) {
                    var beats = findBeats(t)(ws)(we)(refrainDur)(v.value1);
                    return map(function (b) {
                        return new AST.Onset(v.value0, b);
                    })(beats);
                };
            };
        };
    };
};
var refrainWithIntraIndexes = function (t) {
    return function (ws) {
        return function (we) {
            return function (rhy) {
                var refrainDur = rhythmicToRefrainDuration(rhy);
                var processTuple = function (tup) {
                    return Data_List.zip(Data_Tuple.fst(tup))(fromFoldable(Data_List_Lazy.replicate(Data_List.length(Data_Tuple.fst(tup)))(Data_Tuple.snd(tup))));
                };
                var indexAtWS = Data_Tuple.fst(indexOfRefrain(t)(ws)(rhy));
                var eventsPerRefrain = rhythmicToEventsDuration(rhy);
                var eventsPerRefrainandIndex = Data_List.zip(eventsPerRefrain)(Data_List.range(0)(Data_List.length(eventsPerRefrain) - 1 | 0));
                var processedWsWe = map(function (x) {
                    return new Data_Tuple.Tuple(findBeatsWithOnset(t)(ws)(we)(refrainDur)(Data_Tuple.fst(x)), Data_Tuple.snd(x));
                })(map(function (x) {
                    return new Data_Tuple.Tuple((function (v) {
                        return new AST.Onset(v.value0, v.value1 * refrainDur);
                    })(Data_Tuple.fst(x)), Data_Tuple.snd(x));
                })(eventsPerRefrainandIndex));
                var toEventProcess = map(function (x) {
                    return new Data_Tuple.Tuple((function (v) {
                        return new AST.Onset(v.value0, v.value1);
                    })(Data_Tuple.fst(x)), Data_Int.toNumber(Data_Tuple.snd(x)));
                })(Data_List.concat(map(function (x) {
                    return processTuple(x);
                })(processedWsWe)));
                return sort(toEventProcess);
            };
        };
    };
};
var auralise = function (v) {
    return function (v1) {
        if (v1 instanceof AST.S) {
            if (eq1(v1.value1)(AST.ByEvent.value)) {
                var s = Data_Maybe.fromMaybe("")(Data_List.index(v1.value0)(mod(v.value1.value1)(Data_List.length(v1.value0))));
                return {
                    s: s,
                    whenPosix: v.value0
                };
            };
            if (Data_Boolean.otherwise) {
                return {
                    s: "",
                    whenPosix: 0.0
                };
            };
        };
        if (v1 instanceof AST.N) {
            return {
                s: "",
                whenPosix: 0.0
            };
        };
        throw new Error("Failed pattern match at Motor (line 61, column 1 - line 61, column 62): " + [ v.constructor.name, v1.constructor.name ]);
    };
};
var auraliseMap = function (v) {
    return function (au) {
        if (v instanceof AST.Events) {
            return map(function (x) {
                return auralise(x)(au);
            })(v.value0);
        };
        return new Data_List_Types.Cons({
            s: "",
            whenPosix: 0.0
        }, Data_List_Types.Nil.value);
    };
};
var amountOfRefrainsPerW = function (firstR) {
    return function (lastR) {
        return function (firstE) {
            return function (lastE) {
                return function (lenE) {
                    if (firstR === lastR) {
                        return Data_List.range(firstE)(lastE);
                    };
                    if ((firstR + 1 | 0) === lastR) {
                        var lastEvents = map(function (x) {
                            return x + lenE | 0;
                        })(Data_List.range(0)(lastE));
                        return Data_List.concat(fromFoldable1([ Data_List.range(firstE)(lenE - 1 | 0), lastEvents ]));
                    };
                    if (Data_Boolean.otherwise) {
                        var xs = fromFoldable(Data_List_Lazy.replicate((lastR - firstR | 0) - 1 | 0)(Data_List.range(0)(lenE - 1 | 0)));
                        var scl = scanl(add1)(0)(fromFoldable(Data_List_Lazy.replicate(Data_List.length(xs))(lenE)));
                        var zpd = Data_List.concat(Data_List.zipWith(function (x) {
                            return function (y) {
                                return map(function (x1) {
                                    return x1 + y | 0;
                                })(x);
                            };
                        })(xs)(scl));
                        var realLast = map(function (x) {
                            return x + Data_Int.floor(Data_Int.toNumber(lenE) * Data_Int.toNumber(lastR)) | 0;
                        })(Data_List.range(0)(lastE));
                        return Data_List.concat(fromFoldable1([ Data_List.range(firstE)(lenE - 1 | 0), zpd, realLast ]));
                    };
                    throw new Error("Failed pattern match at Motor (line 115, column 1 - line 115, column 67): " + [ firstR.constructor.name, lastR.constructor.name, firstE.constructor.name, lastE.constructor.name, lenE.constructor.name ]);
                };
            };
        };
    };
};
var eventProcessXS = function (t) {
    return function (ws) {
        return function (we) {
            return function (rhy) {
                var xs = refrainWithIntraIndexes(t)(ws)(we)(rhy);
                var refrainDur = rhythmicToRefrainDuration(rhy);
                var lastLocation = Data_Maybe.fromMaybe(new Data_Tuple.Tuple(new AST.Onset(false, 0.0), 0.0))(Data_List.last(xs));
                var lastEvent = Data_Int.floor(Data_Tuple.snd(lastLocation));
                var lastBeat = Data_Int.floor((function (v) {
                    return v.value1 / refrainDur;
                })(Data_Tuple.fst(lastLocation)));
                var firstLocation = Data_Maybe.fromMaybe(new Data_Tuple.Tuple(new AST.Onset(false, 0.0), 0.0))(Data_List.head(xs));
                var firstEvent = Data_Int.floor(Data_Tuple.snd(firstLocation));
                var firstBeat = Data_Int.floor((function (v) {
                    return v.value1 / refrainDur;
                })(Data_Tuple.fst(firstLocation)));
                var elapsedRefrains = Data_Tuple.fst(lmap(function (v) {
                    return v.value1;
                })(firstLocation)) / refrainDur;
                var dbg6 = trace("lastBeat " + show(lastBeat))(function (v) {
                    return lastBeat;
                });
                var dbg5 = trace("firstBeat " + show(firstBeat))(function (v) {
                    return firstBeat;
                });
                var dbg4 = trace("elapsedRefrains " + show1(elapsedRefrains))(function (v) {
                    return elapsedRefrains;
                });
                var dbg3 = trace("refrainDur " + show1(refrainDur))(function (v) {
                    return refrainDur;
                });
                var dbg2 = trace("lastLocation " + show2(lastLocation))(function (v) {
                    return lastLocation;
                });
                var dbg1 = trace("firstLocation " + show2(firstLocation))(function (v) {
                    return firstLocation;
                });
                var dbg0 = trace("indices " + show3(xs))(function (v) {
                    return xs;
                });
                var amountOfEvents = Data_List.length(rhythmicToEventsDuration(rhy));
                var offset = Data_Int.floor(elapsedRefrains) * amountOfEvents | 0;
                var i = map(function (x) {
                    return offset + x | 0;
                })(amountOfRefrainsPerW(firstBeat)(lastBeat)(firstEvent)(lastEvent)(amountOfEvents));
                return Data_List.zipWith(function (x) {
                    return function (y) {
                        return new Data_Tuple.Tuple(Data_Tuple.fst(x), Data_Int.toNumber(y));
                    };
                })(xs)(i);
            };
        };
    };
};
var eventProcess = function (t) {
    return function (ws) {
        return function (we) {
            return function (v) {
                if (v instanceof AST.Rhythmics) {
                    return new AST.Events(map(function (x) {
                        return indexedOnsetToEvent(x)(t);
                    })(eventProcessXS(t)(ws)(we)(new AST.Rhythmics(v.value0))));
                };
                var xs = refrainWithIntraIndexes(t)(ws)(we)(v);
                var refrainDur = rhythmicToRefrainDuration(v);
                var lastLocation = Data_Maybe.fromMaybe(new Data_Tuple.Tuple(new AST.Onset(false, 0.0), 0.0))(Data_List.last(xs));
                var firstLocation = Data_Maybe.fromMaybe(new Data_Tuple.Tuple(new AST.Onset(false, 0.0), 0.0))(Data_List.head(xs));
                var eventsLen = Data_Int.toNumber(Data_List.length(rhythmicToEventsDuration(v)));
                var elapsedRefrains = Data_Tuple.fst(lmap(function (v1) {
                    return v1.value1;
                })(firstLocation)) / refrainDur;
                var offset = Data_Int.toNumber(Data_Int.floor(elapsedRefrains)) * eventsLen;
                var is = sort1(Data_List.concat(map(manyCycles(eventsLen))(map(Data_List_NonEmpty.toList)(groupAll(map(function (x) {
                    return offset + x;
                })(map(Data_Tuple.snd)(xs)))))));
                var dbg7 = trace("lastLocation " + show2(lastLocation))(function (v1) {
                    return lastLocation;
                });
                var dbg6 = trace("indices " + show4(is))(function (v1) {
                    return is;
                });
                var dbg5 = trace("offset " + show1(offset))(function (v1) {
                    return offset;
                });
                var dbg4 = trace("elapsedRefrains " + show1(elapsedRefrains))(function (v1) {
                    return elapsedRefrains;
                });
                var dbg3 = trace("refrainTotalDur " + show1(refrainDur))(function (v1) {
                    return refrainDur;
                });
                var dbg2 = trace("eventsPerRefr " + show1(eventsLen))(function (v1) {
                    return eventsLen;
                });
                var dbg1 = trace("firstLocation " + show2(firstLocation))(function (v1) {
                    return firstLocation;
                });
                return new AST.Events(map(function (x) {
                    return indexedOnsetToEvent(x)(t);
                })(Data_List.zipWith(function (x) {
                    return function (i) {
                        return new Data_Tuple.Tuple(Data_Tuple.fst(x), i);
                    };
                })(xs)(is)));
            };
        };
    };
};
var testy = function (t) {
    return function (ws) {
        return function (we) {
            var process = eventProcess(t)(ws)(we)(new AST.Rhythmics(new Data_List_Types.Cons(Helpers.x, new Data_List_Types.Cons(Helpers.x, new Data_List_Types.Cons(Helpers.x, new Data_List_Types.Cons(Helpers.x, Data_List_Types.Nil.value))))));
            return auraliseMap(process)(new AST.S(new Data_List_Types.Cons("bd", new Data_List_Types.Cons("cp", new Data_List_Types.Cons("808", Data_List_Types.Nil.value))), AST.ByEvent.value));
        };
    };
};
var allAurals = function (process) {
    return function (aurals) {
        return Data_List.concat(map(function (x) {
            return auraliseMap(process)(x);
        })(aurals));
    };
};
var programToWaste = function (t) {
    return function (ws) {
        return function (we) {
            return function ($$eval) {
                return function (v) {
                    var process = eventProcess(t)(ws)(we)(v.value0);
                    return allAurals(process)(v.value2);
                };
            };
        };
    };
};
export {
    eventProcess,
    programToWaste
};
