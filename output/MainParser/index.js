// Generated by purs version 0.15.4
import * as Control_Alt from "../Control.Alt/index.js";
import * as Control_Applicative from "../Control.Applicative/index.js";
import * as Control_Bind from "../Control.Bind/index.js";
import * as Data_Either from "../Data.Either/index.js";
import * as Data_Foldable from "../Data.Foldable/index.js";
import * as Data_Functor from "../Data.Functor/index.js";
import * as Data_Int from "../Data.Int/index.js";
import * as Data_List_Types from "../Data.List.Types/index.js";
import * as Data_Show from "../Data.Show/index.js";
import * as Data_Tuple from "../Data.Tuple/index.js";
import * as Parsing from "../Parsing/index.js";
import * as Parsing_Combinators from "../Parsing.Combinators/index.js";
import * as Parsing_Language from "../Parsing.Language/index.js";
import * as Parsing_String from "../Parsing.String/index.js";
import * as Parsing_Token from "../Parsing.Token/index.js";
var show = /* #__PURE__ */ Data_Show.show(Data_Show.showNumber);
var show1 = /* #__PURE__ */ Data_Show.show(/* #__PURE__ */ Data_Tuple.showTuple(Data_Show.showNumber)(Data_Show.showNumber));
var bind = /* #__PURE__ */ Control_Bind.bind(Parsing.bindParserT);
var alt = /* #__PURE__ */ Control_Alt.alt(Parsing.altParserT);
var pure = /* #__PURE__ */ Control_Applicative.pure(Parsing.applicativeParserT);
var discard = /* #__PURE__ */ Control_Bind.discard(Control_Bind.discardUnit)(Parsing.bindParserT);
var choice = /* #__PURE__ */ Parsing_Combinators.choice(Data_Foldable.foldableArray);
var map = /* #__PURE__ */ Data_Functor.map(Data_List_Types.functorList);
var Proportion = /* #__PURE__ */ (function () {
    function Proportion(value0) {
        this.value0 = value0;
    };
    Proportion.create = function (value0) {
        return new Proportion(value0);
    };
    return Proportion;
})();
var BPM = /* #__PURE__ */ (function () {
    function BPM(value0) {
        this.value0 = value0;
    };
    BPM.create = function (value0) {
        return new BPM(value0);
    };
    return BPM;
})();
var CPS = /* #__PURE__ */ (function () {
    function CPS(value0) {
        this.value0 = value0;
    };
    CPS.create = function (value0) {
        return new CPS(value0);
    };
    return CPS;
})();
var Passage = /* #__PURE__ */ (function () {
    function Passage() {

    };
    Passage.value = new Passage();
    return Passage;
})();
var Origin = /* #__PURE__ */ (function () {
    function Origin() {

    };
    Origin.value = new Origin();
    return Origin;
})();
var Eval = /* #__PURE__ */ (function () {
    function Eval() {

    };
    Eval.value = new Eval();
    return Eval;
})();
var Diverge = /* #__PURE__ */ (function () {
    function Diverge() {

    };
    Diverge.value = new Diverge();
    return Diverge;
})();
var ConvergeFromOrigin = /* #__PURE__ */ (function () {
    function ConvergeFromOrigin(value0, value1) {
        this.value0 = value0;
        this.value1 = value1;
    };
    ConvergeFromOrigin.create = function (value0) {
        return function (value1) {
            return new ConvergeFromOrigin(value0, value1);
        };
    };
    return ConvergeFromOrigin;
})();
var ConvergeFromEval = /* #__PURE__ */ (function () {
    function ConvergeFromEval(value0, value1) {
        this.value0 = value0;
        this.value1 = value1;
    };
    ConvergeFromEval.create = function (value0) {
        return function (value1) {
            return new ConvergeFromEval(value0, value1);
        };
    };
    return ConvergeFromEval;
})();
var Polytemporal = /* #__PURE__ */ (function () {
    function Polytemporal(value0, value1, value2) {
        this.value0 = value0;
        this.value1 = value1;
        this.value2 = value2;
    };
    Polytemporal.create = function (value0) {
        return function (value1) {
            return function (value2) {
                return new Polytemporal(value0, value1, value2);
            };
        };
    };
    return Polytemporal;
})();
var Program = /* #__PURE__ */ (function () {
    function Program(value0, value1) {
        this.value0 = value0;
        this.value1 = value1;
    };
    Program.create = function (value0) {
        return function (value1) {
            return new Program(value0, value1);
        };
    };
    return Program;
})();
var voicingShowInstance = {
    show: function (v) {
        if (v instanceof Proportion) {
            return show(v.value0);
        };
        if (v instanceof BPM) {
            return show1(v.value0);
        };
        if (v instanceof CPS) {
            return show(v.value0);
        };
        throw new Error("Failed pattern match at MainParser (line 87, column 1 - line 90, column 24): " + [ v.constructor.name ]);
    }
};
var show2 = /* #__PURE__ */ Data_Show.show(/* #__PURE__ */ Data_List_Types.showList(voicingShowInstance));
var tokenParser = /* #__PURE__ */ Parsing_Token.makeTokenParser(Parsing_Language.haskellStyle);
var whitespace = /* #__PURE__ */ (function () {
    return tokenParser.whiteSpace;
})();
var semi = /* #__PURE__ */ (function () {
    return tokenParser.semi;
})();
var reserved = /* #__PURE__ */ (function () {
    return tokenParser.reserved;
})();
var passageShowInstance = {
    show: function (v) {
        return "passage";
    }
};
var show3 = /* #__PURE__ */ Data_Show.show(/* #__PURE__ */ Data_List_Types.showList(passageShowInstance));
var parseOrigin = /* #__PURE__ */ bind(/* #__PURE__ */ alt(/* #__PURE__ */ Parsing_String.string("origin"))(/* #__PURE__ */ Parsing_String.string("o")))(function () {
    return pure(Origin.value);
});
var parseEval = /* #__PURE__ */ bind(/* #__PURE__ */ alt(/* #__PURE__ */ Parsing_String.string("eval"))(/* #__PURE__ */ Parsing_String.string("e")))(function () {
    return pure(Eval.value);
});
var parseDiv = /* #__PURE__ */ bind(/* #__PURE__ */ alt(/* #__PURE__ */ Parsing_String.string("diverge"))(/* #__PURE__ */ Parsing_String.string("d")))(function () {
    return pure(Diverge.value);
});
var parens = /* #__PURE__ */ (function () {
    return tokenParser.parens;
})();
var noseShowInstance = {
    show: function (v) {
        if (v instanceof Origin) {
            return "origin";
        };
        if (v instanceof Eval) {
            return "eval";
        };
        throw new Error("Failed pattern match at MainParser (line 94, column 1 - line 96, column 21): " + [ v.constructor.name ]);
    }
};
var show4 = /* #__PURE__ */ Data_Show.show(/* #__PURE__ */ Data_List_Types.showList(noseShowInstance));
var nfToNum = function (v) {
    if (v instanceof Data_Either.Left) {
        return Data_Int.toNumber(v.value0);
    };
    if (v instanceof Data_Either.Right) {
        return v.value0;
    };
    throw new Error("Failed pattern match at MainParser (line 272, column 1 - line 272, column 40): " + [ v.constructor.name ]);
};
var naturalOrFloat = /* #__PURE__ */ (function () {
    return tokenParser.naturalOrFloat;
})();
var parseCPSMark = /* #__PURE__ */ bind(naturalOrFloat)(function (x) {
    return pure(nfToNum(x));
});
var parseConvE = /* #__PURE__ */ bind(/* #__PURE__ */ alt(/* #__PURE__ */ Parsing_String.string("convergeFromEval"))(/* #__PURE__ */ Parsing_String.string("c-e")))(function () {
    return discard(whitespace)(function () {
        return bind(naturalOrFloat)(function (x) {
            return bind(naturalOrFloat)(function (y) {
                return pure(new ConvergeFromEval(nfToNum(x), nfToNum(y)));
            });
        });
    });
});
var parseConvO = /* #__PURE__ */ bind(/* #__PURE__ */ alt(/* #__PURE__ */ Parsing_String.string("convergeFromOrigin"))(/* #__PURE__ */ Parsing_String.string("c-o")))(function () {
    return discard(whitespace)(function () {
        return bind(naturalOrFloat)(function (x) {
            return bind(naturalOrFloat)(function (y) {
                return pure(new ConvergeFromOrigin(nfToNum(x), nfToNum(y)));
            });
        });
    });
});
var parseSingleCPS = /* #__PURE__ */ bind(naturalOrFloat)(function (x) {
    return bind(alt(Parsing_String.string("cycle"))(alt(Parsing_String.string("cps"))(Parsing_String.string("c"))))(function () {
        return pure(new CPS(nfToNum(x)));
    });
});
var parseSingleProp = /* #__PURE__ */ bind(naturalOrFloat)(function (x) {
    return bind(alt(Parsing_String.string("proportion"))(alt(Parsing_String.string("prop"))(Parsing_String.string("p"))))(function () {
        return pure(new Proportion(nfToNum(x)));
    });
});
var parseSingleTempo = /* #__PURE__ */ bind(naturalOrFloat)(function (x) {
    return bind(naturalOrFloat)(function (y) {
        return bind(alt(Parsing_String.string("tempo"))(alt(Parsing_String.string("bpm"))(Parsing_String.string("t"))))(function () {
            return pure(new BPM(new Data_Tuple.Tuple(nfToNum(x), nfToNum(y))));
        });
    });
});
var parseTempoMark = /* #__PURE__ */ bind(naturalOrFloat)(function (x) {
    return bind(naturalOrFloat)(function (y) {
        return pure(new Data_Tuple.Tuple(nfToNum(x), nfToNum(y)));
    });
});
var integer = /* #__PURE__ */ (function () {
    return tokenParser.integer;
})();
var identifier = /* #__PURE__ */ (function () {
    return tokenParser.identifier;
})();
var $$float = /* #__PURE__ */ (function () {
    return tokenParser["float"];
})();
var discardA = function (dictMonad) {
    var bind1 = Control_Bind.bind(dictMonad.Bind1());
    return function (m) {
        return function (k) {
            return bind1(m)(function (v) {
                return k;
            });
        };
    };
};
var defaultTempo = /* #__PURE__ */ (function () {
    return new Data_Tuple.Tuple(120.0, 0.25);
})();
var parseDefTempo = /* #__PURE__ */ bind(/* #__PURE__ */ Parsing_String.string("global"))(function (x) {
    return pure(defaultTempo);
});
var defaultCPS = 0.5;
var parseDefCPS = /* #__PURE__ */ bind(/* #__PURE__ */ Parsing_String.string("global"))(function (x) {
    return pure(defaultCPS);
});
var convergeShowInstance = {
    show: function (v) {
        if (v instanceof Diverge) {
            return "diverge";
        };
        if (v instanceof ConvergeFromOrigin) {
            return "convergeOrigin" + (show(v.value0) + (" " + show(v.value1)));
        };
        if (v instanceof ConvergeFromEval) {
            return "convergeEval" + (show(v.value0) + (" " + show(v.value1)));
        };
        throw new Error("Failed pattern match at MainParser (line 102, column 1 - line 105, column 76): " + [ v.constructor.name ]);
    }
};
var show5 = /* #__PURE__ */ Data_Show.show(/* #__PURE__ */ Data_List_Types.showList(convergeShowInstance));
var polytemporalShowInstance = {
    show: function (v) {
        return "poly " + (show2(v.value0) + (" " + (show4(v.value1) + (" " + show5(v.value2)))));
    }
};
var show6 = /* #__PURE__ */ Data_Show.show(polytemporalShowInstance);
var programShowInstance = {
    show: function (v) {
        return "poly " + (show6(v.value0) + (" " + ("pass " + show3(v.value1))));
    }
};
var comma = /* #__PURE__ */ (function () {
    return tokenParser.comma;
})();
var parseByVoice = /* #__PURE__ */ bind(/* #__PURE__ */ Parsing_Combinators.sepBy(/* #__PURE__ */ choice([ /* #__PURE__ */ Parsing_Combinators["try"](parseSingleProp), /* #__PURE__ */ Parsing_Combinators["try"](parseSingleCPS), /* #__PURE__ */ Parsing_Combinators["try"](parseSingleTempo) ]))(comma))(function (x) {
    return pure(x);
});
var parseConverge = /* #__PURE__ */ discard(whitespace)(function () {
    return bind(Parsing_Combinators.sepBy(choice([ parseDiv, parseConvO, parseConvE ]))(comma))(function (x) {
        return pure(x);
    });
});
var parseNose = /* #__PURE__ */ bind(/* #__PURE__ */ Parsing_Combinators.sepBy(/* #__PURE__ */ choice([ parseOrigin, parseEval ]))(comma))(function (x) {
    return pure(x);
});
var parsebpms = /* #__PURE__ */ discard(whitespace)(function () {
    return bind(alt(Parsing_String.string("tempi"))(alt(Parsing_String.string("tempos"))(Parsing_String.string("bpms"))))(function () {
        return bind(parens(Parsing_Combinators.sepBy(choice([ parseTempoMark, parseDefTempo ]))(comma)))(function (x) {
            return pure(map(BPM.create)(x));
        });
    });
});
var parsecpss = /* #__PURE__ */ bind(/* #__PURE__ */ Parsing_String.string("cycles"))(function () {
    return bind(parens(Parsing_Combinators.sepBy(choice([ parseCPSMark, parseDefCPS ]))(comma)))(function (x) {
        return pure(map(CPS.create)(x));
    });
});
var parseproportions = /* #__PURE__ */ bind(/* #__PURE__ */ Parsing_String.string("proportions"))(function () {
    return bind(parens(Parsing_Combinators.sepBy(naturalOrFloat)(comma)))(function (x) {
        return pure(map(function (x$prime) {
            return new Proportion(nfToNum(x$prime));
        })(x));
    });
});
var parsevoicings = /* #__PURE__ */ discard(whitespace)(function () {
    return bind(choice([ parens(parseByVoice), Parsing_Combinators["try"](parsebpms), Parsing_Combinators["try"](parseproportions), Parsing_Combinators["try"](parsecpss) ]))(function (x) {
        return pure(x);
    });
});
var colon = /* #__PURE__ */ (function () {
    return tokenParser.colon;
})();
var canonise = /* #__PURE__ */ discard(whitespace)(function () {
    return bind(Parsing_String.string("canonise "))(function () {
        return discard(whitespace)(function () {
            return bind(parsevoicings)(function (x) {
                return discard(whitespace)(function () {
                    return bind(parens(parseNose))(function (y) {
                        return discard(whitespace)(function () {
                            return bind(parens(parseConverge))(function (z) {
                                return pure(new Polytemporal(x, y, z));
                            });
                        });
                    });
                });
            });
        });
    });
});
var polytemporal = /* #__PURE__ */ choice([ canonise ]);
var brackets = /* #__PURE__ */ (function () {
    return tokenParser.brackets;
})();
var braces = /* #__PURE__ */ (function () {
    return tokenParser.braces;
})();
export {
    Program,
    Passage,
    Polytemporal,
    Proportion,
    BPM,
    CPS,
    Origin,
    Eval,
    Diverge,
    ConvergeFromOrigin,
    ConvergeFromEval,
    polytemporal,
    canonise,
    parseConverge,
    parseDiv,
    parseConvO,
    parseConvE,
    parseNose,
    parseOrigin,
    parseEval,
    parsevoicings,
    parseByVoice,
    parseSingleProp,
    parseSingleTempo,
    parseSingleCPS,
    parseproportions,
    parsebpms,
    parseDefTempo,
    parseTempoMark,
    defaultTempo,
    parsecpss,
    parseDefCPS,
    defaultCPS,
    parseCPSMark,
    discardA,
    nfToNum,
    tokenParser,
    parens,
    braces,
    identifier,
    reserved,
    naturalOrFloat,
    $$float as float,
    whitespace,
    colon,
    brackets,
    comma,
    semi,
    integer,
    programShowInstance,
    passageShowInstance,
    polytemporalShowInstance,
    voicingShowInstance,
    noseShowInstance,
    convergeShowInstance
};
