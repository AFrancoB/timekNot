// Generated by purs version 0.15.4
import * as AST from "../AST/index.js";
import * as Data_Either from "../Data.Either/index.js";
import * as Data_Eq from "../Data.Eq/index.js";
import * as Data_List_Types from "../Data.List.Types/index.js";
import * as Data_Traversable from "../Data.Traversable/index.js";
import * as Data_Unit from "../Data.Unit/index.js";
import * as Effect from "../Effect/index.js";
import * as Parser from "../Parser/index.js";
import * as Parsing from "../Parsing/index.js";
import * as Test_QuickCheck from "../Test.QuickCheck/index.js";
var eq = /* #__PURE__ */ Data_Eq.eq(/* #__PURE__ */ Data_Either.eqEither(Parsing.eqParseError)(AST.eqProgram));
var xxxx = /* #__PURE__ */ (function () {
    return new AST.Rhythmics(new Data_List_Types.Cons(AST.X.value, new Data_List_Types.Cons(AST.X.value, new Data_List_Types.Cons(AST.X.value, new Data_List_Types.Cons(AST.X.value, Data_List_Types.Nil.value)))));
})();
var xxoxxxoox = /* #__PURE__ */ (function () {
    return new AST.Rhythmics(new Data_List_Types.Cons(AST.X.value, new Data_List_Types.Cons(AST.X.value, new Data_List_Types.Cons(AST.O.value, new Data_List_Types.Cons(AST.X.value, new Data_List_Types.Cons(AST.X.value, new Data_List_Types.Cons(AST.X.value, new Data_List_Types.Cons(AST.O.value, new Data_List_Types.Cons(AST.O.value, new Data_List_Types.Cons(AST.X.value, Data_List_Types.Nil.value))))))))));
})();
var xxox = /* #__PURE__ */ (function () {
    return new AST.Rhythmics(new Data_List_Types.Cons(AST.X.value, new Data_List_Types.Cons(AST.X.value, new Data_List_Types.Cons(AST.O.value, new Data_List_Types.Cons(AST.X.value, Data_List_Types.Nil.value)))));
})();
var xxOXx = /* #__PURE__ */ (function () {
    return new AST.Rhythmics(new Data_List_Types.Cons(AST.X.value, new Data_List_Types.Cons(AST.X.value, new Data_List_Types.Cons(new AST.Sd(new AST.Rhythmics(new Data_List_Types.Cons(AST.O.value, new Data_List_Types.Cons(AST.X.value, Data_List_Types.Nil.value)))), new Data_List_Types.Cons(AST.X.value, Data_List_Types.Nil.value)))));
})();
var repeat = true;
var ooox = /* #__PURE__ */ (function () {
    return new AST.Rhythmics(new Data_List_Types.Cons(AST.O.value, new Data_List_Types.Cons(AST.O.value, new Data_List_Types.Cons(AST.O.value, new Data_List_Types.Cons(AST.X.value, Data_List_Types.Nil.value)))));
})();
var nonRep = false;
var defR = /* #__PURE__ */ (function () {
    return AST.O.value;
})();
var defAu = /* #__PURE__ */ (function () {
    return new Data_List_Types.Cons(new AST.S(new Data_List_Types.Cons("", Data_List_Types.Nil.value), AST.ByEvent.value), Data_List_Types.Nil.value);
})();
var main = function __do() {
    Data_Traversable.traverse(Data_Traversable.traversableArray)(Effect.applicativeEffect)(Test_QuickCheck.quickCheck(Test_QuickCheck.testableResult))([ Test_QuickCheck.withHelp(eq(Parsing.runParser("")(Parser.parseTop))(new Data_Either.Right(new AST.Program(defR, nonRep, defAu))))("empty program"), Test_QuickCheck.withHelp(eq(Parsing.runParser("x :|")(Parser.parseTop))(new Data_Either.Right(new AST.Program(AST.X.value, repeat, defAu))))("simple x with repetition program, no waste produced"), Test_QuickCheck.withHelp(eq(Parsing.runParser("o :|")(Parser.parseTop))(new Data_Either.Right(new AST.Program(AST.O.value, repeat, defAu))))("simple o with repetition program, no waste produced"), Test_QuickCheck.withHelp(eq(Parsing.runParser("xxox :|")(Parser.parseTop))(new Data_Either.Right(new AST.Program(xxox, repeat, defAu))))("a list of rhythmics: xxox, no waste produced"), Test_QuickCheck.withHelp(eq(Parsing.runParser("xxo xxx oox :|")(Parser.parseTop))(new Data_Either.Right(new AST.Program(xxoxxxoox, repeat, defAu))))("a list of rhythmics with spaces should generate same structure than a program withoutn spaces, no waste produced"), Test_QuickCheck.withHelp(eq(Parsing.runParser("[xxox] :|")(Parser.parseTop))(new Data_Either.Right(new AST.Program(new AST.Sd(xxox), repeat, defAu))))("a subdivision with a list of rhythmics: xxox, no waste produced"), Test_QuickCheck.withHelp(eq(Parsing.runParser("xx[ox]x :|")(Parser.parseTop))(new Data_Either.Right(new AST.Program(xxOXx, repeat, defAu))))("a list of rhythmics and a subdivision within: xx[ox]x, no waste produced"), Test_QuickCheck.withHelp(eq(Parsing.runParser("[xx[ox]x] :|")(Parser.parseTop))(new Data_Either.Right(new AST.Program(new AST.Sd(xxOXx), repeat, defAu))))("a subdivision with a list of rhythmics and a subdivision within: xx[ox]x, no waste produced"), Test_QuickCheck.withHelp(eq(Parsing.runParser("[xxxx] [ooox] :|")(Parser.parseTop))(new Data_Either.Right(new AST.Program(new AST.Rhythmics(new Data_List_Types.Cons(new AST.Sd(xxxx), new Data_List_Types.Cons(new AST.Sd(ooox), Data_List_Types.Nil.value))), repeat, defAu))))("two parallel subdivision patterns"), Test_QuickCheck.withHelp(eq(Parsing.runParser("!xxox#2 :|")(Parser.parseTop))(new Data_Either.Right(new AST.Program(new AST.Repeat(xxox, 2), repeat, defAu))))("testing repetition parser"), Test_QuickCheck.withHelp(eq(Parsing.runParser("[!xxox#2] :|")(Parser.parseTop))(new Data_Either.Right(new AST.Program(new AST.Sd(new AST.Repeat(xxox, 2)), repeat, defAu))))("testing repetition parser"), Test_QuickCheck.withHelp(eq(Parsing.runParser("!xxox#2 xx[ox]x :|")(Parser.parseTop))(new Data_Either.Right(new AST.Program(new AST.Rhythmics(new Data_List_Types.Cons(new AST.Repeat(xxox, 2), new Data_List_Types.Cons(xxOXx, Data_List_Types.Nil.value))), repeat, defAu))))("testing repetition parser"), Test_QuickCheck.withHelp(eq(Parsing.runParser("!xx[ox]x#2 ooox :|")(Parser.parseTop))(new Data_Either.Right(new AST.Program(new AST.Rhythmics(new Data_List_Types.Cons(new AST.Repeat(xxOXx, 2), new Data_List_Types.Cons(ooox, Data_List_Types.Nil.value))), repeat, defAu))))("testing repetition parser") ])();
    return Data_Unit.unit;
};
export {
    main,
    xxox,
    xxOXx,
    xxxx,
    ooox,
    xxoxxxoox,
    repeat,
    nonRep,
    defAu,
    defR
};
